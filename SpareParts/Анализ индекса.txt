Анализ индекса messages_pkey в PostgreSQL

1. Размер индекса и таблицы
Размер индекса: 10.3 ГБ (11069980672 байт)
Размер таблицы: 22.7 ГБ (24372666368 байт)
Отношение индекса к таблице: 45.42%
Вывод:
Индекс занимает почти половину размера таблицы, что может указывать на:
Широкий первичный ключ (например, UUID или составной ключ из нескольких столбцов).
Потенциально избыточный индекс, если PK редко используется для запросов.

2. Использование индекса (index_scans)
Всего сканирований индекса: 186,588,040
Доля сканирований от общего числа обращений к таблице: 0.49%
Вывод:
Индекс используется редко (менее 0.5% всех операций).
Это ненормально для первичного ключа, который обычно участвует в JOIN, WHERE id = ..., ORDER BY id.
Возможные причины:
Большинство запросов используют другие индексы или полноценные сканы таблицы (Seq Scan).
Приложение редко фильтрует данные по PK.

3. Эффективность доступа (tuples_read и tuples_fetched)
Всего строк прочитано (tuples_read): 307,245,646
Всего строк фактически получено (tuples_fetched): 305,917,309
Процент прочитанных строк от общего числа в таблице: ~243.78%
Процент полученных строк от общего числа в таблице: ~242.73%
Вывод:
Индекс используется неэффективно:
Чтение почти всех строк таблицы через индекс (tuples_read) — значит, индекс часто применяется для полного или почти полного сканирования, а не точечного доступа.
Высокий tuples_fetched подтверждает, что большинство операций — не точечные выборки, а массовые чтения.
243% означает, что каждая строка в таблице читалась в среднем 2.43 раза через индекс — это очень много для PK.

Основные проблемы и рекомендации
1. Проблемы
Низкая полезность индекса
PK сканируется редко (0.49% обращений), но когда используется — читает почти всю таблицу.
Это бесполезная нагрузка на индекс, если он не ускоряет критичные запросы.

Возможное раздувание (bloat)
Индекс занимает ~45% от размера таблицы, что подозрительно много для PK.
Нужно проверить pg_stat_user_indexes и pgstattuple на фрагментацию.

Неоптимальные запросы
Если индекс используется для полного сканирования, возможно, запросы не используют PK для фильтрации, а вместо этого:
Делают SELECT * FROM messages (без WHERE).
Используют другие индексы.

2. Рекомендации
1. Проверить фрагментацию индекса
	SELECT * FROM pgstattuple('messages_pkey');  -- проверка bloat
	Если free_space высокий — сделать REINDEX INDEX messages_pkey.
	2. Оптимизировать запросы
	Убедиться, что запросы с WHERE id = ... или JOIN используют PK.
	Если PK почти не используется, рассмотреть замену на другой индекс (например, если часто фильтруют по created_at).
	3. Уменьшить размер PK
	Если PK — UUID или составной ключ, возможно, стоит перейти на BIGSERIAL.
	4. Настроить autovacuum
	Убедиться, что autovacuum работает часто, чтобы избежать bloat.

Итоговый вердикт
Первичный ключ messages_pkey работает неэффективно:
Редко используется для точечных запросов.
Часто сканируется почти полностью, создавая лишнюю нагрузку.
Занимает много места (возможен bloat).

Что делать?
Проверить запросы — почему PK не используется для фильтрации?
Оптимизировать индекс — уменьшить размер, перестроить (REINDEX).
Рассмотреть альтернативы — если PK не нужен, заменить на более полезный индекс.